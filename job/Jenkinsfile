// function to create new folder in workspace in this job where we clone the repo and copy the file to the desired location
def cloneRepositoryIfNotExists(Map jobConfig) {
    println 'Cloning repository... !!!!!'
    println "Repository URL: ${jobConfig.githubUrl} , Branch Name: ${jobConfig.branchName}, Folder Path: ${jobConfig.repoPath}"

    String folderPath = jobConfig.repoPath
    String repoUrl = jobConfig.githubUrl
    String branchName = jobConfig.branchName
    // Ensure the target directory exists
    sh "mkdir -p ${folderPath}"

    // Check if git repository already exists then skip cloning
    if (fileExists("${folderPath}/.git")) {
        println "Git repository already exists in ${folderPath}. Skipping clone."
        return
    }

    // clone the repository
    dir(folderPath) {
        sh """
            git init
            git remote add origin ${repoUrl}
            git fetch origin ${branchName}:${branchName} --depth=10
            git checkout ${branchName}
        """
        println 'Repository cloned successfully.'
    }
}

// function fetch latest changes
def renameBranchAndFetch(Map jobConfig) {
    println 'Fetching latest changes... !!!!!'
    String branchName = jobConfig.branchName
    String repoPath = jobConfig.repoPath
    String backupBranchName = "backup_${branchName}"
    println "Renaming branch '${branchName}' to '${backupBranchName}' and fetching again..."
    println "Repository Path: ${repoPath}"

    // Use dir() to change directory context for all operations
    dir(repoPath) {
        sh """
            git branch -D ${branchName} || true
            git branch -m ${branchName} ${backupBranchName} || true
            git fetch origin ${branchName}:${branchName}
            git checkout ${branchName}
            git branch -D ${backupBranchName} || true
        """
        println 'Branch renamed and fetched successfully.'
        println 'Current branches:'
        sh 'git branch -a'
    }
}

// main function to track commit and audit
def trackCommitAndAudit(Map jobConfig) {
    println 'Tracking changes... !!!!!'
    println "Tracking changes for branch: ${jobConfig.branchName} in repo: ${jobConfig.repoPath}"

    // 1. Read last line from audit file to get last processed commit hash
    def lastLine = readAuditFileLastLine(jobConfig.auditFilePath)
    def lastProcessedCommitHash = null
    if (lastLine) {
        def parts = lastLine.split(',')
        if (parts.length > 0) {
            lastProcessedCommitHash = parts[0].trim()
            println "Last processed commit hash from audit file: ${lastProcessedCommitHash}"
        }
    } else {
        println 'Audit file is empty or only contains header.'
        // add sencond last commit to audit file
        dir(jobConfig.repoPath) {
            def secondLastCommit = sh(script: "git log --pretty=format:'%H' -2 | tail -n 1", returnStdout: true).trim()
            if (secondLastCommit) {
                println "Adding second last commit to audit file: ${secondLastCommit}"
                addCommitInfoToAuditFile(secondLastCommit, jobConfig)
                lastProcessedCommitHash = secondLastCommit
            } else {
                println 'No commits found in the repository.'
            }
        }
    }

    if(!lastProcessedCommitHash) {
        currentBuild.result = 'UNSTABLE'
        println 'No last processed commit hash found after checking second last commit. Exiting.'
        return
    }

    // 2. Get All commits after last processed commit hash and get them as list
    def newCommits = getAllCommitHashesAfter(jobConfig, lastProcessedCommitHash)
    if (!newCommits) {
        currentBuild.result = 'UNSTABLE'
        println 'No new commits found. Skipping commit listing.'
        return
    }
    def isDesiredFileChanged = false;
    // 3. For each commit check if desired file path is modified in that commit
    newCommits.each { commit ->
        def hasChanges = evaluateCommitForFilePath(jobConfig, commit)
        if (hasChanges) {
            isDesiredFileChanged = true
            addCommitInfoToAuditFile(commit, jobConfig)
        }
    }
    if (!isDesiredFileChanged) {
        currentBuild.result = 'UNSTABLE'
        println "No new commits modified the desired file path: ${jobConfig.filePath}"
    }

}

// create function that accept commit hash and add all info in audit file as commitHash, author, date, message
// using commit hash it extract all info
def addCommitInfoToAuditFile(String commitHash, Map jobConfig) {
    println 'Adding commit info to audit file... !!!!!'
    println "Adding commit info to audit file for commit hash: ${commitHash}"
    // Extract commit details using git log
    dir(jobConfig.repoPath) {
        def commitDetails = sh(script: "git log -1 --pretty=format:'%H,%an,%ad,%s' --date=iso ${commitHash}", returnStdout: true).trim()
        println "Extracted commit details: ${commitDetails}"
        def existingContent = readFile(file: jobConfig.auditFilePath)
        def updatedContent = existingContent + "${commitDetails}\n"
        writeFile file: jobConfig.auditFilePath, text: updatedContent
    }
    println "Commit details appended to audit file: ${jobConfig.auditFilePath}"
}

// logic to check if the commit has changes for desired file path
def hasChangesForFilePath(Map jobConfig, String commitHash) {
    println "Checking if commit ${commitHash} has changes for file path: ${jobConfig.filePath}"
    dir(jobConfig.repoPath) {
        def changedFiles = sh(script: "git diff-tree --no-commit-id --name-only -r ${commitHash}", returnStdout: true).trim()
        if (changedFiles) {
            def filesList = changedFiles.split('\n')
            if (filesList.contains(jobConfig.filePath)) {
                println "Commit ${commitHash} modifies the desired file path: ${jobConfig.filePath}"
                return true
            } else {
                println "Commit ${commitHash} does not modify the desired file path: ${jobConfig.filePath}. Skipping."
                return false
            }
        } else {
            println "No files changed in commit ${commitHash}."
            return false
        }
    }
}

// Read Audit File Last Line and return the last line
def readAuditFileLastLine(String auditFilePath) {
    println 'Reading last line from audit file... !!!!!'
    println "Reading last line from audit file: ${auditFilePath}"
    if (fileExists(auditFilePath)) {
        def content = readFile(file: auditFilePath).trim()
        def lines = content.split('\n')
        if (lines.length > 1) {
            return lines[-1] // Return the last line
        }
    }
    return null
}

// In git repository print all commit hashes after some commit hash and return them as list
def getAllCommitHashesAfter(Map jobConfig, String commitHash) {
    println 'Getting all commit hashes after specified commit... !!!!!'
    println "Listing all commit hashes after: ${commitHash} in repo: ${jobConfig.repoPath}"
    dir(jobConfig.repoPath) {
        def commits = sh(script: "git log --pretty=format:'%H' ${commitHash}..HEAD", returnStdout: true).trim()
        if (commits) {
            println "Commits after ${commitHash}:"
            def commitList = []
            commits.split('\n').each { line ->
                println line
                commitList << line
            }
            return commitList
        } else {
            currentBuild.result = 'UNSTABLE'
            println "No new commits found after ${commitHash}."
        }
    }
}

// function to evaluate commit info 
// 1. which file changed in commit
// 2. if file path match with desired file path then only add to audit file otherwise skip
def evaluateCommitForFilePath(Map jobConfig, String commitHash) {
    println 'Evaluating commit for file path... !!!!!'
    println "Evaluating commit: ${commitHash} for file path: ${jobConfig.filePath} in repo: ${jobConfig.repoPath}"
    dir(jobConfig.repoPath) {
        def changedFiles = sh(script: "git diff-tree --no-commit-id --name-only -r ${commitHash}", returnStdout: true).trim()
        println "Changed files in commit ${commitHash}: ${changedFiles}"
        if (changedFiles) {
            def filesList = changedFiles.split('\n')
            // check for preprod file path
            if (filesList.contains(jobConfig.gitFilePathPreprod)) {
                println "Commit ${commitHash} modifies the desired file path: ${jobConfig.filePath}"
                return true
            }
            if (filesList.contains(jobConfig.gitFilePathProd)) {
                println "Commit ${commitHash} modifies the desired file path: ${jobConfig.filePath}"
                return true
            } else {
                println "Commit ${commitHash} does not modify the desired file path: ${jobConfig.filePath}. Skipping."
                return false
            }
        } else {
            println "No files changed in commit ${commitHash}."
            return false
        }
    }
}

pipeline {
    agent any
    
    environment {
        REPO_FOLDER = 'resourceBundle'
        AUDIT_FILE = 'i18n_audit.csv'
    }
    
    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        skipDefaultCheckout()
    }
    
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo '==============================='
                    echo 'Starting I18n Resource File Sync Job'
                    echo '==============================='
                    
                    // Set workspace paths as script variables
                    def workspacePath = pwd()
                    def repoPath = "${workspacePath}/${env.REPO_FOLDER}"
                    def auditFilePath = "${workspacePath}/${env.AUDIT_FILE}"
                    
                    // Store in environment for use in later stages
                    env.WORKSPACE_PATH = workspacePath
                    env.REPO_PATH = repoPath
                    env.AUDIT_FILE_PATH = auditFilePath
                    
                    echo "Workspace: ${workspacePath}"
                    echo "Repository Path: ${repoPath}"
                    echo "Audit File: ${auditFilePath}"
                }
            }
        }
        
        stage('Load Configuration') {
            steps {
                script {
                    echo 'Loading configuration from i18n-sync.properties...'

                    if (!fileExists('i18n-sync.properties')) {
                        error 'Properties file not found in workspace: i18n-sync.properties'
                    }

                    def fileContent = readFile('i18n-sync.properties')
                    
                    def props = [:]
                    fileContent.split('\n').each { line ->
                        line = line.trim()
                        if (line && !line.startsWith('#')) {
                            def parts = line.split('=', 2)
                            if (parts.length == 2) {
                                props[parts[0].trim()] = parts[1].trim()
                            }
                        }
                    }

                    // print props for debugging
                    echo "Loaded properties: ${props}"
                    // Store properties in environment variables
                    env.GITHUB_URL = props['github-url'] ?: ''
                    env.BRANCH_NAME = props['branch-name'] ?: ''
                    env.I18N_GIT_PATH_PREPROD = props['i18n-git-path-preprod'] ?: ''
                    env.I18N_SERVER_PATH_PREPROD = props['i18n-server-path-preprod'] ?: ''
                    env.I18N_GIT_PATH_PROD = props['i18n-git-path-prod'] ?: ''
                    env.I18N_SERVER_PATH_PROD = props['i18n-server-path-prod'] ?: ''

                    echo "Configuration loaded successfully"
                }
            }
        }

        stage('Initialize Audit File') {
            steps {
                script {
                    echo 'Initializing audit file...'
                    if (!fileExists(env.AUDIT_FILE_PATH)) {
                        echo "Creating new audit file: ${env.AUDIT_FILE_PATH}"
                        writeFile file: env.AUDIT_FILE_PATH, text: 'CommitHash,Author,Date,Message\n'
                    } else {
                        echo "Audit file already exists: ${env.AUDIT_FILE_PATH}"
                        def lineCount = sh(script: "wc -l < '${env.AUDIT_FILE_PATH}'", returnStdout: true).trim()
                        echo "Current audit file has ${lineCount} lines"
                    }
                }
            }
        }
        
        stage('Clone Repository') {
            steps {
                script {
                    def config = [
                        githubUrl: env.GITHUB_URL,
                        branchName: env.BRANCH_NAME,
                        auditFilePath: env.AUDIT_FILE_PATH,
                        repoPath: env.REPO_PATH,
                        gitFilePathPreprod: env.I18N_GIT_PATH_PREPROD,
                        gitFilePathProd: env.I18N_GIT_PATH_PROD,
                        serverFilePathPreprod: env.I18N_SERVER_PATH_PREPROD,
                        serverFilePathProd: env.I18N_SERVER_PATH_PROD
                    ]
                    echo "Cloning repository: ${config.githubUrl}"
                    cloneRepositoryIfNotExists(config)
                }
            }
        }
        
        stage('Fetch Latest Changes') {
            steps {
                script {
                    def config = [
                        githubUrl: env.GITHUB_URL,
                        filePath: env.FILE_PATH,
                        branchName: env.BRANCH_NAME,
                        auditFilePath: env.AUDIT_FILE_PATH,
                        repoPath: env.REPO_PATH
                    ]
                    echo "Fetching latest changes for branch: ${config.branchName}"
                    renameBranchAndFetch(config)
                }
            }
        }
        
        stage('Track Commits') {
            steps {
                script {
                    def config = [
                        githubUrl: env.GITHUB_URL,
                        filePath: env.FILE_PATH,
                        branchName: env.BRANCH_NAME,
                        auditFilePath: env.AUDIT_FILE_PATH,
                        repoPath: env.REPO_PATH
                    ]
                    echo "Tracking and auditing commits..."
                    trackCommitAndAudit(config)
                }
            }
        }
        
        stage('Archive Audit File') {
            steps {
                script {
                    echo 'Archiving audit file as build artifact...'
                    archiveArtifacts artifacts: "${env.AUDIT_FILE}", allowEmptyArchive: false, fingerprint: true
                }
            }
        }
    }
    
    post {
        success {
            echo '=============================='
            echo 'Pipeline completed successfully!'
            echo '=============================='
        }
        failure {
            echo '=============================='
            echo 'Pipeline failed!'
            echo '=============================='
        }
        always {
            script {
                echo 'Cleaning up workspace (optional)...'
                // Uncomment to clean workspace after build
                // cleanWs()
            }
        }
    }
}
