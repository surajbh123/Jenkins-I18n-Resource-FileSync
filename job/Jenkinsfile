// function to create new folder in workspace in this job where we clone the repo and copy the file to the desired location
def cloneRepositoryIfNotExists(Map jobConfig) {
    println 'Cloning repository... !!!!!'
    println "Repository URL: ${jobConfig.githubUrl} , Branch Name: ${jobConfig.branchName}, Folder Path: ${jobConfig.repoPath}"

    String folderPath = jobConfig.repoPath
    String repoUrl = jobConfig.githubUrl
    String branchName = jobConfig.branchName
    // Ensure the target directory exists
    sh "mkdir -p ${folderPath}"

    // Check if git repository already exists then skip cloning
    if (fileExists("${folderPath}/.git")) {
        println "Git repository already exists in ${folderPath}. Skipping clone."
        return
    }

    // clone the repository
    dir(folderPath) {
        sh """
            git init
            git remote add origin ${repoUrl}
            git fetch origin ${branchName}:${branchName} --depth=10
            git checkout ${branchName}
        """
        println 'Repository cloned successfully.'
    }
}

// function fetch latest changes
def renameBranchAndFetch(Map jobConfig) {
    println 'Fetching latest changes... !!!!!'
    String branchName = jobConfig.branchName
    String repoPath = jobConfig.repoPath
    String backupBranchName = "backup_${branchName}"
    println "Renaming branch '${branchName}' to '${backupBranchName}' and fetching again..."
    println "Repository Path: ${repoPath}"

    // Use dir() to change directory context for all operations
    dir(repoPath) {
        sh """
            git branch -D ${branchName} || true
            git branch -m ${branchName} ${backupBranchName} || true
            git fetch origin ${branchName}:${branchName}
            git checkout ${branchName}
            git branch -D ${backupBranchName} || true
        """
        println 'Branch renamed and fetched successfully.'
        println 'Current branches:'
        sh 'git branch -a'
    }
}

// main function to track commit and audit
def trackCommitAndAudit(Map jobConfig) {
    println 'Tracking changes... !!!!!'
    println "Tracking changes for branch: ${jobConfig.branchName} in repo: ${jobConfig.repoPath}"

    // 1. Read last line from audit file to get last processed commit hash
    def lastLine = readAuditFileLastLine(jobConfig.auditFilePath)
    def lastProcessedCommitHash = null
    if (lastLine) {
        def parts = lastLine.split(',')
        if (parts.length > 0) {
            lastProcessedCommitHash = parts[0].trim()
            println "Last processed commit hash from audit file: ${lastProcessedCommitHash}"
        }
    } else {
        println 'Audit file is empty or only contains header.'
        // add sencond last commit to audit file
        dir(jobConfig.repoPath) {
            def secondLastCommit = sh(script: "git log --pretty=format:'%H' -2 | tail -n 1", returnStdout: true).trim()
            if (secondLastCommit) {
                println "Adding second last commit to audit file: ${secondLastCommit}"
                addCommitInfoToAuditFile(secondLastCommit, jobConfig)
                lastProcessedCommitHash = secondLastCommit
            } else {
                println 'No commits found in the repository.'
            }
        }
    }

    // 2. Get All commits after last processed commit hash and get them as list
    if (lastProcessedCommitHash) {
        def newCommits = getAllCommitHashesAfter(jobConfig, lastProcessedCommitHash)
        if (newCommits) {
            newCommits.each { commit ->
                addCommitInfoToAuditFile(commit, jobConfig)
            }
        }
    } else {
        println 'No last processed commit hash found. Skipping commit listing.'
    }
}

// create function that accept commit hash and add all info in audit file as commitHash, author, date, message
// using commit hash it extract all info
def addCommitInfoToAuditFile(String commitHash, Map jobConfig) {
    println 'Adding commit info to audit file... !!!!!'
    println "Adding commit info to audit file for commit hash: ${commitHash}"
    // Extract commit details using git log
    dir(jobConfig.repoPath) {
        def commitDetails = sh(script: "git log -1 --pretty=format:'%H,%an,%ad,%s' --date=iso ${commitHash}", returnStdout: true).trim()
        println "Extracted commit details: ${commitDetails}"
        def existingContent = readFile(file: jobConfig.auditFilePath)
        def updatedContent = existingContent + "${commitDetails}\n"
        writeFile file: jobConfig.auditFilePath, text: updatedContent
    }
    println "Commit details appended to audit file: ${jobConfig.auditFilePath}"
}


// Read Audit File Last Line and return the last line
def readAuditFileLastLine(String auditFilePath) {
    println 'Reading last line from audit file... !!!!!'
    println "Reading last line from audit file: ${auditFilePath}"
    if (fileExists(auditFilePath)) {
        def content = readFile(file: auditFilePath).trim()
        def lines = content.split('\n')
        if (lines.length > 1) {
            return lines[-1] // Return the last line
        }
    }
    return null
}

// In git repository print all commit hashes after some commit hash and return them as list
def getAllCommitHashesAfter(Map jobConfig, String commitHash) {
    println 'Getting all commit hashes after specified commit... !!!!!'
    println "Listing all commit hashes after: ${commitHash} in repo: ${jobConfig.repoPath}"
    dir(jobConfig.repoPath) {
        def commits = sh(script: "git log --pretty=format:'%H' ${commitHash}..HEAD", returnStdout: true).trim()
        if (commits) {
            println "Commits after ${commitHash}:"
            def commitList = []
            commits.split('\n').each { line ->
                println line
                commitList << line
            }
            return commitList
        } else {
            println "No new commits found after ${commitHash}."
        }
    }
}

// function to evaluate commit info 
// 1. which file changed in commit
// 2. if file path match with desired file path then only add to audit file otherwise skip
def evaluateCommitForFilePath(Map jobConfig, String commitHash) {
    println 'Evaluating commit for file path... !!!!!'
    println "Evaluating commit: ${commitHash} for file path: ${jobConfig.filePath} in repo: ${jobConfig.repoPath}"
    dir(jobConfig.repoPath) {
        def changedFiles = sh(script: "git diff-tree --no-commit-id --name-only -r ${commitHash}", returnStdout: true).trim()
        if (changedFiles) {
            def filesList = changedFiles.split('\n')
            if (filesList.contains(jobConfig.filePath)) {
                println "Commit ${commitHash} modifies the desired file path: ${jobConfig.filePath}"
                return true
            } else {
                println "Commit ${commitHash} does not modify the desired file path: ${jobConfig.filePath}. Skipping."
                return false
            }
        } else {
            println "No files changed in commit ${commitHash}."
            return false
        }
    }
}

pipeline {
    agent any
    stages {
        stage('I18n Resource File Sync') {
            steps {
                script {
                    println '==============================='
                    println 'Starting I18n Resource File Sync Job'

                    def workspacePath = pwd()
                    println "Workspace path: ${workspacePath}"
                    def repoFolder = 'resourceBundle'
                    def repoPath = "${workspacePath}/${repoFolder}"

                    // create file in workspace to audit commit that processed with header
                    def auditFilePath = "${workspacePath}/i18n_audit.csv"
                    if (!fileExists(auditFilePath)) {
                        println "Creating audit file with header: ${auditFilePath}"
                        writeFile file: auditFilePath, text: 'CommitHash,Author,Date,Message\n'
                    } else {
                        println "Audit file already exists: ${auditFilePath}"
                    }

                    // The git.properties file is expected to be in the workspace.
                    println 'Checking for properties file: git.properties'

                    if (fileExists('git.properties')) {
                        println 'Found properties file: git.properties'

                        // Read and display the file contents
                        def fileContent = readFile('git.properties')
                        println 'File contents:'
                        println fileContent
                        def props = [:]
                        fileContent.split('\n').each { line ->
                            line = line.trim()
                            if (line && !line.startsWith('#')) {
                                def parts = line.split('=', 2)
                                if (parts.length == 2) {
                                    props[parts[0].trim()] = parts[1].trim()
                                }
                            }
                        }

                        def githubUrl = props.githubUrl
                        def filePath = props.filePath
                        def branchName = props.branchName

                        def jobConfig = [
                            githubUrl: githubUrl,
                            filePath: filePath,
                            branchName: branchName,
                            auditFilePath: auditFilePath,
                            repoPath: repoPath
                        ]

                        cloneRepositoryIfNotExists(jobConfig)
                        renameBranchAndFetch(jobConfig)
                        trackCommitAndAudit(jobConfig)
                    } else {
                        // Fail the build if the properties file is not found
                        error 'Properties file not found in workspace: git.properties'
                    }
                }
            }
        }
    }
}
